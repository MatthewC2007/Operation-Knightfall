import json
import os
import uuid
import glob
from kivy.uix.widget import Widget
from kivy.app import App
from kivy.uix.behaviors import DragBehavior
from kivy.lang import Builder
from kivy.uix.screenmanager import ScreenManager, Screen
from kivy.core.window import Window
from kivy.config import Config
from kivy.uix.floatlayout import FloatLayout
from kivy.properties import ObjectProperty, StringProperty, ListProperty
from kivy.uix.progressbar import ProgressBar
from kivy.core.audio import SoundLoader
from kivy.clock import Clock
import random

"""This is a simple note-taking and music player app built with Kivy that 
allows users to create draggable notes (inspired by people who decorate their 
walls with sticky notes with all their thoughts, plans, upcoming events, and for
all those highschool and uni students keeping notes for exams), 
save them, and play (royalty free, but not sellable (under copyright)) music 
with a draggable music player that half works from a folder that you can't 
access from the app."""

Window.maximize() # Start the app maximised

kv="""<DraggableRectangle@DragBehavior+FloatLayout>:
    size_hint: None, None
    size: 250, 320
    drag_timeout: 100000000
    drag_distance: 0
    drag_rectangle: self.x, self.y, self.width, self.height

    canvas.before:
        Color:
            rgba: 0.3, 0.3, 0.3, 0.8 
        Rectangle:
            pos: self.x + 3, self.y - 3
            size: self.size
    canvas:
        Color:
            rgba: root.note_color
        Rectangle:
            pos: self.pos
            size: self.size
    BoxLayout:
        orientation: 'vertical'
        size: root.size
        pos: root.pos
        padding: 10
        spacing: 5

        TextInput:
            id: text_input
            hint_text: "Type your note here..."
            size_hint_y: 0.8
            multiline: True
            scroll_y: 1
            on_parent: root.text_input_ref = self
        BoxLayout:
            size_hint_y: 0.2
            spacing: 20
            Button:
                id: note_save
                text: "Save"
                on_release: root.save_note()
            Button:
                id: note_delete
                text: "Delete"
                on_release: root.delete_note()
        BoxLayout:
            orientation: 'horizontal'
            padding: -5
            spacing: 10
            size_hint_y: 0.15
            pos_hint: {"center_x": 0.5}
            Button:
                background_normal: ''
                background_color: 0.996, 1.0, 0.408, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_color(self.background_color)
            Button:
                background_normal: ''
                background_color: 1.0, 0.757, 0.29, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_color(self.background_color)
            Button:
                background_normal: ''
                background_color: 1.0, 0.443, 0.808, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_color(self.background_color)
            Button:
                background_normal: ''
                background_color:  0.729, 0.247, 1.0, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_color(self.background_color)
            Button:
                background_normal: ''
                background_color:  0.463, 0.753, 0.839, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_color(self.background_color)
<Draggablemusicplayer@DragBehavior+FloatLayout>:
    size_hint: None, None
    size: 320, 360
    drag_timeout: 100000000
    drag_distance: 0
    drag_rectangle: self.x, self.y, self.width, self.height
    current_song: "No song loaded"
    canvas.before:
        Color:
            rgba: 0, 0.1, 0.8, 0.8
        RoundedRectangle:
            pos: self.x + 5, self.y - 5
            size: self.size
    canvas:
        Color:
            rgba: 0.1, 0.2, 1, 1  
        RoundedRectangle:
            pos: self.pos
            size: self.size
    BoxLayout:
        orientation: 'vertical'
        size: root.size
        pos: root.pos
        padding: 10
        spacing: 5
        Label:
            id: song_label
            text: root.current_song
            size_hint_y: 0.1
            size_hint_x: 0.8
            pos_hint: {"center_x": 0.5}
            font_size: self.size[1] * 0.25
        ProgressBar:
            id: progress_bar
            size_hint_y: 0.1
            size_hint_x: 0.9
            pos_hint: {"center_x": 0.5}
            max: 100
            value:0
        GridLayout:
            cols: 3
            size_hint_y: 0.08
            padding: 10
            spacing: 5
            Button:
                text: "Back"
                size_hint_y: 0.08
                on_release: root.play_prev()
            Button:
                id:play pause_button
                text: "Play"
                size_hint_y: 0.08
                on_press: root.toggle_music(self)
            Button:
                text:"Skip"
                size_hint_y: 0.08
                on_release: root.play_next()
<WelcomeScreen>:
    FloatLayout:
        Button:
            text: "Hey there, note-taker!"
            font_size: self.size[1] * 0.6
            size_hint: None, None
            size: 100, 100
            pos_hint: {"center_x": 0.5, "center_y": 0.6}
            background_normal: ''
            background_color: 0, 0, 0, 1
            on_release: app.switch_to_secret()
        Label:
            text: "Big plans? Random thoughts? Letâ€™s jot it all down."
            font_size: self.size[1] * 0.4
            size_hint: None, None
            size: 300, 50
            pos_hint: {"center_x": 0.5, "center_y": 0.5}
        Button:
            background_normal: ''
            background_color: 0.341, 0.514, 0.859, 1
            text: "Enter"
            font_size: self.size[1] * 0.5
            size_hint: 0.13, 0.1
            pos_hint: {"center_x": 0.5, "center_y": 0.35}
            on_release: app.switch_to_main_screen()
        Label:
            text: "Please do NOT save any sensitive information here, as this app is not secure."
            color: 1, 0, 0, 1
            font_size: self.size[1] * 0.5
            size_hint: None, None
            size: 300, 30
            pos_hint: {"center_x": 0.5, "center_y": 0.9}
        Label:
            text: "If you want to quit, just tap the X in the top right corner."
            font_size: self.size[1] * 0.4
            size_hint: None, None
            size: 200, 30
            pos_hint: {"center_x": 0.91, "center_y": 0.96}

<MainScreen>:  
    FloatLayout:
        Button:
            text: 'New Note'
            font_size: self.size[1] * 0.5
            size_hint: 0.13, 0.05
            pos_hint: {"x": 0.02, "y": 0.05}
            on_release: app.add_new_rectangle()
               
<Secret>:

 """
Builder.load_string(kv)
Config.set('input', 'mouse', 'mouse,disable_multitouch')
class WelcomeScreen(Screen):
    pass
class MainScreen(Screen):
    pass
class Settings(Screen):
    pass
class Secret(Screen):
    pass
    
class DraggableRectangle(DragBehavior, FloatLayout):
    """
    A draggable note widget. Allows users to move, edit, and colour notes.
    Each note has a unique ID and saves its position, size, text, and colour.
    """
    
    dragging_widget = None # Tracks which note is currently being dragged
    text_input_ref = ObjectProperty(None)
    note_id = StringProperty("note_temp")
    note_color = ListProperty([0.996, 1.0, 0.408, 1])

    def __init__(self, note_id="note_temp", **kwargs):
        """
        Initialise the note with a unique ID and default size.
        Loads saved note data after creation.
        """
        super().__init__(**kwargs)
        self.note_id = note_id
        self.size_hint = (None, None)
        self.size = (250, 300)
        Clock.schedule_once(self.load_note, 0.1) # Load note data after widget is created

    def on_touch_down(self, touch): 
        """ 
        Handle touch down events to start dragging the note.
        If the touch is within the note's area, it will start dragging, and bring
        it to the front.
        """
        if self.collide_point(*touch.pos):
            for child in self.children:
                if child.collide_point(*touch.pos):
                    DraggableRectangle.dragging_widget = self
                    # Bring this widget to front by removing and re-adding it
                    if self.parent:
                        parent = self.parent
                        parent.remove_widget(self)
                        parent.add_widget(self)
                    return super().on_touch_down(touch)
        return super().on_touch_down(touch)

    def on_touch_up(self, touch):
        """
        Handle touch up events to stop dragging the note.
        If the note is being dragged, it will save its position and size.
        """
        if DraggableRectangle.dragging_widget is self:
            DraggableRectangle.dragging_widget = None
            # Save position and size after drag
            app = App.get_running_app()
            app.rectangles[self.note_id] = {
                "x": self.x,
                "y": self.y,
                "width": self.width,
                "height": self.height
            }
            app.save_all_positions()
        return super().on_touch_up(touch)

    def save_note(self):
        """
        Save the note text and color to a JSON file.
        """
        note_path = f'Notes/note_{self.note_id}.json'
        data = {}
        # Load existing data if present
        if os.path.exists(note_path):
            with open(note_path, "r", encoding="utf-8") as f:
                try:
                    data = json.load(f)
                except Exception:
                    data = {}
        # Update both note and color
        if self.text_input_ref:
            data["note"] = self.text_input_ref.text
        data["color"] = self.note_color
        with open(note_path, "w", encoding="utf-8") as f:
            json.dump(data, f)

    def load_note(self, dt=None):
        """
        Load the note text and color from a JSON file.
        If the file does not exist, it sets default values.
        """
        note_path = f'Notes/note_{self.note_id}.json'
        try:
            with open(note_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                if self.text_input_ref:
                    self.text_input_ref.text = data.get("note", "")
                self.note_color = data.get("color", [0.996, 1.0, 0.408, 1])
        except FileNotFoundError:
            if self.text_input_ref:
                self.text_input_ref.text = ""
            self.note_color = [0.996, 1.0, 0.408, 1]

    def delete_note(self):
        """
        Delete the note by removing its JSON file and removes widget from screen.
        Also updates the app's rectangle tracking to remove this note.
        """
        try:
            os.remove(f'Notes/note_{self.note_id}.json')
        except FileNotFoundError:
            pass

        # Inform the main app to remove from position tracking
        app = App.get_running_app()
        if self.note_id in app.rectangles:
            del app.rectangles[self.note_id]
            app.save_all_positions()

        # Remove the widget from the screen
        if self.parent:
            self.parent.remove_widget(self)

    def change_note_color(self, color):
        self.note_color = list(color)  # Ensure it's a list, not a kivy object
        self.save_note_color(color)

    def save_note_color(self, color):
        note_path = f'Notes/note_{self.note_id}.json'
        # Load existing note data if present
        data = {}
        if os.path.exists(note_path):
            with open(note_path, "r") as f:
                try:
                    data = json.load(f)
                except Exception:
                    data = {}
        data["color"] = list(color)
        with open(note_path, "w") as f:
            json.dump(data, f)

class DraggableMusicPlayer(DragBehavior, FloatLayout):
    """
    A draggable music player widget. Allows users to play, pause, and skip songs
    from a shuffled playlist.
    """
    dragging_widget = None
    sound = None
    current_file_index = 0
    current_song = StringProperty("No song loaded")
    shuffled_playlist = []
    is_playing = False
    paused_position = 0
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.progress_event = None
        
    def on_touch_down(self, touch): 
        if self.collide_point(*touch.pos):
            for child in self.children:
                if child.collide_point(*touch.pos):
                    DraggableMusicPlayer.dragging_widget = self
                    # Bring this widget to front by removing and re-adding it
                    if self.parent:
                        parent = self.parent
                        parent.remove_widget(self)
                        parent.add_widget(self)
                    return super().on_touch_down(touch)
        return super().on_touch_down(touch)
    
    def update_progress(self, dt):
        """Update progress bar based on current song position"""
        if self.sound and self.is_playing:
            try:
                # Get current position and length (doesn't work for mp3 files)
                current_pos = self.sound.get_pos()
                total_length = self.sound.length
                print("Current position:", current_pos, "Total length:", total_length)
                if total_length > 0:
                    progress = (current_pos / total_length) * 100
                    self.ids.progress_bar.value = progress
                else:
                    self.ids.progress_bar.value = 0
                # Check if song has ended
                if current_pos >= total_length:
                    self.play_next()
            except:
                self.ids.progress_bar.value = 0

    def play_music(self,song_path):
        """
        Loads and plays the selected song, updating the displayed song name.
        """
        if self.sound:
            self.sound.stop()
            # Cancel existing progress updates
            if self.progress_event:
                self.progress_event.cancel()
        self.sound = SoundLoader.load(song_path)
        if self.sound:
            self.sound.play()
            self.current_song = os.path.basename(song_path)  # Update label with song name
            print("Playing song:", self.current_song)
            self.is_playing = True
            self.progress_event = Clock.schedule_interval(self.update_progress, 1)
        else:
            self.current_song = "Error loading song"
            print("Error loading song:", song_path)
            self.is_playing = False
            
            if hasattr(self.ids, 'play_pause_button'):
                self.ids.play_pause_button.text = 'Pause'

    def toggle_music(self, button):
        """Toggle between play and pause states"""
        if not self.shuffled_playlist:
            self.shuffle_playlist()
            
        if not self.sound and self.shuffled_playlist:
            self.play_current()
            self.is_playing = True
            button.text = 'Pause'
        elif self.sound:
            if self.is_playing:
                self.paused_position = self.sound.get_pos()
                self.sound.stop()
                self.is_playing = False
                button.text = 'Play'
                # Pause progress updates
                if self.progress_event:
                    self.progress_event.cancel()
            else:
                current_song = self.shuffled_playlist[self.current_file_index]
                self.sound = SoundLoader.load(current_song)
                if self.sound:
                    if self.paused_position:
                        self.sound.seek(self.paused_position)
                    self.sound.play()
                    self.is_playing = True
                    button.text = 'Pause'
                    # Resume progress updates
                    self.progress_event = Clock.schedule_interval(self.update_progress, 0.1)

    def shuffle_playlist(self):
        """Shuffle the music files and store as playlist"""
        app = App.get_running_app()
        files = app.get_music_files()
        if files:
            self.shuffled_playlist = files.copy()
            random.shuffle(self.shuffled_playlist)
            self.current_file_index = 0

    def play_next(self):
        """Play next song in shuffled playlist"""
        if self.shuffled_playlist:
            self.current_file_index = (self.current_file_index + 1) % len(self.shuffled_playlist)
            self.play_music(self.shuffled_playlist[self.current_file_index])

    def play_prev(self):
        """Play previous song in shuffled playlist"""
        if self.shuffled_playlist:
            self.current_file_index = (self.current_file_index - 1) % len(self.shuffled_playlist)
            self.play_music(self.shuffled_playlist[self.current_file_index])

    def play_current(self):
        """Play current song in playlist"""
        if self.shuffled_playlist:
            self.play_music(self.shuffled_playlist[self.current_file_index])

class MainApp(App):
    def build(self):
        """Build the app."""
        self.rectangles = {}
        self.music_player = {}  # for position saving
        self.music_player_widget = None  # optional reference
        self.sm = ScreenManager()
        self.sm.add_widget(WelcomeScreen(name="welcome"))
        self.sm.add_widget(MainScreen(name="main"))
        self.sm.add_widget(Secret(name="secret"))
        self.load_all_position() 
        return self.sm
        
    def save_all_positions(self):

        with open("rectangles.json", "w") as f:
            json.dump(self.rectangles, f)

        with open("music.json", "w") as f:
            json.dump(self.music_player, f)

    def load_all_position(self):
        try:
            with open("rectangles.json", "r") as f:
                self.rectangles = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.rectangles = {}

        try:
            with open("music.json", "r") as f:
                self.music_player = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.music_player = {}

        main_screen = self.sm.get_screen("main")
        layout = FloatLayout()
        main_screen.add_widget(layout)
    
        for rect_id, pos in self.rectangles.items():
            new_rectangle = DraggableRectangle(note_id=rect_id)
            new_rectangle.size_hint = (None, None)
            # Use saved size if available, else default
            width = pos.get("width", 250)
            height = pos.get("height", 320)
            new_rectangle.size = (width, height)
            new_rectangle.pos = (pos["x"], pos["y"])
            new_rectangle.bind(pos=lambda instance,
                value: self.update_rectangle_pos(rect_id, instance.pos))
            layout.add_widget(new_rectangle)

        # Load persistent music player
        pos = self.music_player.get("music_player", {"x": 1440, "y": 20})  # default position
        music_player = DraggableMusicPlayer()
        music_player.size_hint = (None, None)
        music_player.size = (320, 250)
        music_player.pos = (pos["x"], pos["y"])
        music_player.bind(pos=lambda instance,
                           value: self.update_musicplayer_pos(instance.pos))
        layout.add_widget(music_player)
        self.music_player_widget = music_player  # store a reference if needed

    def switch_to_main_screen(self):
        """Switch to the main screen."""
        self.sm.current = "main"

    def switch_to_secret(self):
        self.sm.current = "secret"

    def add_new_rectangle(self):
        main_screen = self.sm.get_screen("main")
        layout = main_screen.children[0]

        rect_id = str(uuid.uuid4())
        new_rectangle = DraggableRectangle(note_id=rect_id)
        new_rectangle.size_hint = (None, None)
        new_rectangle.size = (250, 300)
        new_rectangle.pos = (100, 100)

        self.rectangles[rect_id] = {"x": 100, "y": 100}
        new_rectangle.bind(pos=lambda instance,
                        value: self.update_rectangle_pos(rect_id, instance.pos))
        layout.add_widget(new_rectangle)
        self.save_all_positions()

    def update_rectangle_pos(self, rect_id, position):
        """Update the position of a rectangle in the dictionary and save."""
        self.rectangles[rect_id] = {"x": position[0], "y": position[1]}
        self.save_all_positions()

    def update_musicplayer_pos(self, pos):
        """Update the position of the music player in the dictionary and save."""
        self.music_player["music_player"] = {"x": pos[0], "y": pos[1]}
        with open("music.json", "w") as f:
                json.dump(self.music_player, f)

    def get_music_files(self):
        """Return a list of audio file paths in the Music folder."""
        music_dir = os.path.join(os.getcwd(), "Music")
        if not os.path.exists(music_dir):
            os.makedirs(music_dir)
        # You can add more extensions if needed
        files = glob.glob(os.path.join(music_dir, "*.mp3")) + \
                glob.glob(os.path.join(music_dir, "*.wav")) + \
                glob.glob(os.path.join(music_dir, "*.ogg"))
        return files

if __name__ == '__main__':
    MainApp().run()