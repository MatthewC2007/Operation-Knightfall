"""Sticky note + music player (Kivy).

A lightweight, insecure (do not store sensitive data) desktop scratchboard:
- Create, drag, recolour, save, and delete sticky notes.
- Drag a simple music player that shuffles royalty‑free tracks from the local Music/ folder.
- Remembers widget positions between runs.

Limitations:
- No auth / encryption.
- Music folder not browsable from the UI (drop files in manually).
- Basic error handling only.

Future ideas (optional):
- Add file picker for music.
- Search / tag notes.
- Export / import notes.
- Dark / light theme toggle.
- Schedule reminders for notes.
- Expandable notes (resize).

Created by Matthew Carter

Last updated: 15/08/2025
"""

import json
import os
import uuid
import glob
import random
import logging

from kivy.app import App
from kivy.lang import Builder
from kivy.config import Config
from kivy.clock import Clock
from kivy.core.audio import SoundLoader
from kivy.core.window import Window
from kivy.properties import ObjectProperty, StringProperty, ListProperty
from kivy.uix.behaviors import DragBehavior
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.screenmanager import ScreenManager, Screen
from kivy.uix.progressbar import ProgressBar

# Logging configuration (PEP8: module-level constants / setup near top)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

DEFAULT_NOTE_COLOUR = [0.996, 1.0, 0.408, 1]

kv = """
<DraggableNote@DragBehavior+FloatLayout>:
    size_hint: None, None
    size: 250, 320
    drag_timeout: 100000000
    drag_distance: 0
    drag_rectangle: self.x, self.y, self.width, self.height

    canvas.before:
        Color:
            rgba: 0.3, 0.3, 0.3, 0.8 
        Rectangle:
            pos: self.x + 3, self.y - 3
            size: self.size
    canvas:
        Color:
            rgba: root.note_colour
        Rectangle:
            pos: self.pos
            size: self.size
    BoxLayout:
        orientation: 'vertical'
        size: root.size
        pos: root.pos
        padding: 10
        spacing: 5

        TextInput:
            id: text_input
            hint_text: "Type your note here..."
            size_hint_y: 0.8
            multiline: True
            scroll_y: 1
            on_parent: root.text_input_ref = self
        BoxLayout:
            size_hint_y: 0.2
            spacing: 20
            Button:
                id: note_save
                text: "Save"
                on_release: root.save_note()
            Button:
                id: note_delete
                text: "Delete"
                on_release: root.delete_note()
        BoxLayout:
            orientation: 'horizontal'
            padding: -5
            spacing: 10
            size_hint_y: 0.15
            pos_hint: {"center_x": 0.5}
            Button:
                background_normal: ''
                background_color: 0.996, 1.0, 0.408, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_colour(self.background_color)
            Button:
                background_normal: ''
                background_color: 1.0, 0.757, 0.29, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_colour(self.background_color)
            Button:
                background_normal: ''
                background_color: 1.0, 0.443, 0.808, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_colour(self.background_color)
            Button:
                background_normal: ''
                background_color:  0.729, 0.247, 1.0, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_colour(self.background_color)
            Button:
                background_normal: ''
                background_color:  0.463, 0.753, 0.839, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_colour(self.background_color)
<DraggableMusicPlayer@DragBehavior+FloatLayout>:
    size_hint: None, None
    size: 320, 360
    drag_timeout: 100000000
    drag_distance: 0
    drag_rectangle: self.x, self.y, self.width, self.height
    current_song: "No song loaded"
    canvas.before:
        Color:
            rgba: 0, 0.1, 0.8, 0.8
        RoundedRectangle:
            pos: self.x + 5, self.y - 5
            size: self.size
    canvas:
        Color:
            rgba: 0.1, 0.2, 1, 1  
        RoundedRectangle:
            pos: self.pos
            size: self.size
    BoxLayout:
        orientation: 'vertical'
        size: root.size
        pos: root.pos
        padding: 10
        spacing: 5
        Label:
            id: song_label
            text: root.current_song
            size_hint_y: 0.1
            size_hint_x: 0.8
            pos_hint: {"center_x": 0.5}
            font_size: self.size[1] * 0.25
        ProgressBar:
            id: progress_bar
            size_hint_y: 0.1
            size_hint_x: 0.9
            pos_hint: {"center_x": 0.5}
            max: 100
            value:0
        GridLayout:
            cols: 3
            size_hint_y: 0.08
            padding: 10
            spacing: 5
            Button:
                text: "Back"
                size_hint_y: 0.08
                on_release: root.play_prev()
            Button:
                id: play_pause_button
                text: "Play"
                size_hint_y: 0.08
                on_press: root.toggle_music(self)
            Button:
                text:"Skip"
                size_hint_y: 0.08
                on_release: root.play_next()
<WelcomeScreen>:
    FloatLayout:
        Button:
            text: "Hey there, note-taker!"
            font_size: self.size[1] * 0.6
            size_hint: None, None
            size: 600, 100
            pos_hint: {"center_x": 0.5, "center_y": 0.6}
            background_normal: ''
            background_color: 0, 0, 0, 1
            on_release: app.switch_to_secret()
        Label:
            text: "Big plans? Random thoughts? Let’s jot it all down."
            font_size: self.size[1] * 0.4
            size_hint: None, None
            size: 300, 100
            pos_hint: {"center_x": 0.5, "center_y": 0.5}
        Button:
            background_normal: ''
            background_color: 0.341, 0.514, 0.859, 1
            text: "Enter"
            font_size: self.size[1] * 0.5
            size_hint: 0.13, 0.1
            pos_hint: {"center_x": 0.5, "center_y": 0.35}
            on_release: app.switch_to_main_screen()
        Label:
            text: "Please do NOT save any sensitive information here, as this app is not secure."
            color: 1, 0, 0, 1
            font_size: self.size[1] * 0.5
            size_hint: None, None
            size: 300, 30
            pos_hint: {"center_x": 0.5, "center_y": 0.9}
        Label:
            text: "If you want to quit, just tap the X in the top right corner."
            font_size: self.size[1] * 0.4
            size_hint: None, None
            size: 200, 30
            pos_hint: {"center_x": 0.91, "center_y": 0.96}

<MainScreen>:  
    FloatLayout:
        Button:
            text: 'New Note'
            font_size: self.size[1] * 0.5
            size_hint: 0.13, 0.05
            pos_hint: {"x": 0.02, "y": 0.05}
            on_release: app.add_new_note()
               
<Secret>:
    FloatLayout:
        Image:
            source: 'staring-avatar-guy-meme-template-full-439b18bc.png'
            allow_stretch: True
            keep_ratio: False
    FloatLayout:
        Button:
            text: "Back"
            font_size: self.size[1] * 0.5
            size_hint: 0.05, 0.05
            pos_hint: {"x": 0.02, "y": 0.05}
            on_release: app.switch_to_welcome_screen()
 """
Builder.load_string(kv)
Config.set('input', 'mouse', 'mouse,disable_multitouch')
Window.maximize()  # Start the app maximised


class WelcomeScreen(Screen):
    """Welcome / landing screen."""
    pass


class MainScreen(Screen):
    """Primary screen holding notes and music player."""
    pass


class Settings(Screen):
    """(Placeholder) settings screen."""
    pass


class Secret(Screen):
    pass

class DraggableNote(DragBehavior, FloatLayout):
    """
    A draggable note widget. Allows users to move, edit, and colour notes.
    Each note has a unique ID and saves its position, size, text, and colour.
    """
    dragging_widget = None  # Tracks which note is currently being dragged
    text_input_ref = ObjectProperty(None)
    note_id = StringProperty("note_temp")
    note_colour = ListProperty(DEFAULT_NOTE_COLOUR)

    def __init__(self, note_id="note_temp", **kwargs):
        """Initialize the note with a unique ID and set up event handlers."""
        super().__init__(**kwargs)
        self.note_id = note_id
        self.size_hint = (None, None)
        self.size = (250, 300)
        Clock.schedule_once(self.load_note, 0.1)
        Clock.schedule_once(lambda dt: self.clamp_to_window(), 0.2)
        Window.bind(size=self._on_window_resize)

    def _on_window_resize(self, *args):
        """Handle window resize events to keep the note within bounds."""
        self.clamp_to_window()

    def clamp_to_window(self):
        """Keep the note fully inside the window."""
        w, h = Window.size
        new_x = min(max(self.x, 0), max(0, w - self.width))
        new_y = min(max(self.y, 0), max(0, h - self.height))
        if (new_x, new_y) != (self.x, self.y):
            self.pos = (new_x, new_y)

    def on_touch_down(self, touch):
        """Handle touch down events to start dragging."""
        if self.collide_point(*touch.pos):
            for child in self.children:
                if child.collide_point(*touch.pos):
                    DraggableNote.dragging_widget = self
                    # If the note is being dragged, ensure it stays on top of other widgets
                    if self.parent:
                        parent = self.parent
                        parent.remove_widget(self)
                        parent.add_widget(self)
                    return super().on_touch_down(touch)
        return super().on_touch_down(touch)

    def on_touch_move(self, touch):
        """Handle touch move events to drag the note."""
        result = super().on_touch_move(touch)
        if DraggableNote.dragging_widget is self:
            self.clamp_to_window()
        return result

    def on_touch_up(self, touch):
        """Handle touch up events to stop dragging."""
        if DraggableNote.dragging_widget is self:
            DraggableNote.dragging_widget = None
            self.clamp_to_window()
            app = App.get_running_app()
            # Save the position and size of the note (separate per note ID JSON)
            app.notes_positions[self.note_id] = {
                "x": self.x,
                "y": self.y,
                "width": self.width,
                "height": self.height
            }
            app.save_all_positions()
        return super().on_touch_up(touch)

    def save_note(self):
        """
        Save the note text and colour to a JSON file.
        """
        note_path = f'Notes/note_{self.note_id}.json'
        data = {}
        # Load existing data if present
        if os.path.exists(note_path):
            with open(note_path, "r", encoding="utf-8") as f:
                try:
                    data = json.load(f)
                except Exception:
                    data = {}
        # Update both note and colour
        if self.text_input_ref:
            data["note"] = self.text_input_ref.text
        data["color"] = self.note_colour
        with open(note_path, "w", encoding="utf-8") as f:
            json.dump(data, f)

    def load_note(self, dt=None):
        """
        Load the note text and colour from a JSON file.
        If the file does not exist, it sets default values.
        """
        note_path = f'Notes/note_{self.note_id}.json'
        try:
            with open(note_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                if self.text_input_ref:
                    self.text_input_ref.text = data.get("note", "")
                self.note_colour = data.get("color", DEFAULT_NOTE_COLOUR)
        except FileNotFoundError:
            if self.text_input_ref:
                self.text_input_ref.text = ""
            self.note_colour = DEFAULT_NOTE_COLOUR.copy()

    def delete_note(self):
        """
        Delete the note by removing its JSON file and removes widget from screen.
        Also updates the app's bote tracking to remove this note.
        """
        try:
            os.remove(f'Notes/note_{self.note_id}.json')
        except FileNotFoundError:
            pass

        # Inform the main app to remove from position tracking
        app = App.get_running_app()
        if self.note_id in app.notes_positions:
            del app.notes_positions[self.note_id]
            app.save_all_positions()

        # Remove the widget from the screen
        if self.parent:
            self.parent.remove_widget(self)

    def change_note_colour(self, color):
        """Change the colour of the note."""
        self.note_colour = list(color)  # Ensure it's a list, not a kivy object
        self.save_note_colour(color)

    def save_note_colour(self, color):
        """Save the note colour to a JSON file."""
        note_path = f'Notes/note_{self.note_id}.json'
        # Load existing note data if present
        data = {}
        if os.path.exists(note_path):
            with open(note_path, "r") as f:
                try:
                    data = json.load(f)
                except Exception:
                    data = {}
        data["color"] = list(color)
        with open(note_path, "w") as f:
            json.dump(data, f)

class DraggableMusicPlayer(DragBehavior, FloatLayout):
    """
    A draggable music player widget. Allows users to play, pause, and skip songs
    from a shuffled playlist.
    """
    dragging_widget = None
    sound = None
    current_file_index = 0
    current_song = StringProperty("No song loaded")
    shuffled_playlist = []
    is_playing = False
    paused_position = 0

    def __init__(self, **kwargs):
        """Initialize the music player and bind to window resize events."""
        super().__init__(**kwargs)
        self.progress_event = None
        self._replacing_track = False
        Clock.schedule_once(lambda dt: self.clamp_to_window(), 0.1)
        Window.bind(size=self._on_window_resize)

    def _on_window_resize(self, *args):
        """Handle window resize events to keep the player within bounds."""
        self.clamp_to_window()

    def clamp_to_window(self):
        """Keep the player fully inside the window."""
        w, h = Window.size
        new_x = min(max(self.x, 0), max(0, w - self.width))
        new_y = min(max(self.y, 0), max(0, h - self.height))
        if (new_x, new_y) != (self.x, self.y):
            self.pos = (new_x, new_y)

    def on_touch_down(self, touch):
        """Handle touch down events to start dragging the player."""
        if self.collide_point(*touch.pos):
            for child in self.children:
                if child.collide_point(*touch.pos):
                    DraggableMusicPlayer.dragging_widget = self
                    if self.parent:
                        parent = self.parent
                        parent.remove_widget(self)
                        parent.add_widget(self)
                    return super().on_touch_down(touch)
        return super().on_touch_down(touch)

    def on_touch_move(self, touch):
        """Handle touch move events to drag the player."""
        result = super().on_touch_move(touch)
        if DraggableMusicPlayer.dragging_widget is self:
            self.clamp_to_window()
        return result

    def on_touch_up(self, touch):
        """Handle touch up events to stop dragging the player."""
        if DraggableMusicPlayer.dragging_widget is self:
            DraggableMusicPlayer.dragging_widget = None
            self.clamp_to_window()
        return super().on_touch_up(touch)

    def update_progress(self, dt):
        """Update progress bar based on current song position."""
        if self.sound and self.is_playing:
            try:
                current_pos = self.sound.get_pos()
                total_length = self.sound.length
                if total_length > 0:
                    self.ids.progress_bar.value = (current_pos / total_length) * 100
                else:
                    self.ids.progress_bar.value = 0
                if total_length > 0 and current_pos >= total_length:
                    self.play_next()
            except Exception as exc:
                logger.debug("Progress update failed: %s", exc)
                self.ids.progress_bar.value = 0

    def play_music(self,song_path):
        """
        Loads and plays the selected song, updating the displayed song name.
        """
        # If an existing sound is playing, stop it without triggering auto-next
        if self.sound:
            self._replacing_track = True
            self.is_playing = False  # Prevent auto-next on old sound stop
            try:
                self.sound.unbind(on_stop=self._on_sound_stop)
            except Exception:
                pass
            self.sound.stop()
            self._replacing_track = False
            if self.progress_event:
                self.progress_event.cancel()

        self.sound = SoundLoader.load(song_path)
        if self.sound:
            self.sound.bind(on_stop=self._on_sound_stop)
            self.sound.play()
            self.current_song = os.path.basename(song_path)
            logger.info("Playing song: %s", self.current_song)
            self.is_playing = True
            # Smoother progress & quicker end detection
            self.progress_event = Clock.schedule_interval(self.update_progress, 0.1)
        else:
            self.current_song = "Error loading song"
            logger.error("Error loading song: %s", song_path)
            self.is_playing = False
            
            if hasattr(self.ids, 'play_pause_button'):
                self.ids.play_pause_button.text = 'Pause'

    def toggle_music(self, button):
        """Toggle between play and pause states"""
        if not self.shuffled_playlist:
            self.shuffle_playlist()

        if not self.sound and self.shuffled_playlist:
            self.play_current()
            button.text = 'Pause'
        elif self.sound:
            if self.is_playing:
                # Mark paused before stopping so on_stop won't advance
                self.is_playing = False
                try:
                    self.sound.unbind(on_stop=self._on_sound_stop)
                except Exception:
                    pass
                self.sound.stop()
                button.text = 'Play'
                if self.progress_event:
                    self.progress_event.cancel()
            else:
                current_song = self.shuffled_playlist[self.current_file_index]
                self.sound = SoundLoader.load(current_song)
                if self.sound:
                    self.sound.bind(on_stop=self._on_sound_stop)
                    if self.paused_position:
                        self.sound.seek(self.paused_position)
                    self.sound.play()
                    self.is_playing = True
                    button.text = 'Pause'
                    self.progress_event = Clock.schedule_interval(self.update_progress, 0.1)

    def shuffle_playlist(self):
        """Shuffle the music files and store as playlist"""
        app = App.get_running_app()
        files = app.get_music_files()
        if files:
            self.shuffled_playlist = files.copy()
            random.shuffle(self.shuffled_playlist)
            self.current_file_index = 0

    def play_next(self):
        """Play next song in shuffled playlist"""
        if self.shuffled_playlist:
            self.current_file_index = (self.current_file_index + 1) % len(self.shuffled_playlist)
            self.play_music(self.shuffled_playlist[self.current_file_index])

    def play_prev(self):
        """Play previous song in shuffled playlist"""
        if self.shuffled_playlist:
            self.current_file_index = (self.current_file_index - 1) % len(self.shuffled_playlist)
            self.play_music(self.shuffled_playlist[self.current_file_index])

    def play_current(self):
        """Play current song in playlist"""
        if self.shuffled_playlist:
            self.play_music(self.shuffled_playlist[self.current_file_index])

    def _on_sound_stop(self, *args):
        """Handle the sound stop event."""
        if not self.is_playing:  # Paused or intentionally stopped
            return
        # Natural end -> next track
        Clock.schedule_once(lambda dt: self.play_next(), 0)

class MainApp(App):
    """Main application class for the note-taking and music player app."""
    def build(self):
        """Build the app."""
        # Dictionary to track each note's positions and sizes
        # Text and colour will be saved in individual note JSON files
        self.notes_positions = {}
        self.music_player = {}  # For position saving
        self.music_player_widget = None  # Reference to the music player widget
        self.sm = ScreenManager()
        self.sm.add_widget(WelcomeScreen(name="welcome"))
        self.sm.add_widget(MainScreen(name="main"))
        self.sm.add_widget(Secret(name="secret"))
        self.load_all_positions() 
        return self.sm
        
    def save_all_positions(self):
        """Save all note and music player positions."""
        with open("notes_positions.json", "w") as f:
            json.dump(self.notes_positions, f)

        with open("music.json", "w") as f:
            json.dump(self.music_player, f)

    def load_all_positions(self):
        """Load all note and music player positions."""
        try:
            with open("notes_positions.json", "r") as f:
                self.notes_positions = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.notes_positions = {}

        try:
            with open("music.json", "r") as f:
                self.music_player = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.music_player = {}

        main_screen = self.sm.get_screen("main")
        layout = FloatLayout()
        main_screen.add_widget(layout)

        # Load saved notes from stored files
        for note_id, pos in self.notes_positions.items():
            new_note = DraggableNote(note_id=note_id)
            new_note.size_hint = (None, None)
            # Use saved size if available, else default
            width = pos.get("width", 250)
            height = pos.get("height", 320)
            new_note.size = (width, height)
            new_note.pos = (pos["x"], pos["y"])
            new_note.bind(pos=lambda instance, value, 
                        rid=note_id: self.update_note_pos(rid, instance.pos)
            )
            layout.add_widget(new_note)

        # Load persistent music player
        pos = self.music_player.get("music_player", {"x": 1440, "y": 20})  # Default position
        music_player = DraggableMusicPlayer()
        music_player.size_hint = (None, None)
        music_player.size = (320, 250)
        music_player.pos = (pos["x"], pos["y"])
        music_player.bind(
            pos=lambda instance, value: self.update_musicplayer_pos(instance.pos)
        )
        layout.add_widget(music_player)
        self.music_player_widget = music_player  # Store a reference if needed

    def switch_to_main_screen(self):
        """Switch to the main screen."""
        self.sm.current = "main"

    def switch_to_welcome_screen(self):
        """Switch to the welcome screen."""
        self.sm.current = "welcome"

    def switch_to_secret(self):
        """Switch to The screen."""
        self.sm.current = "secret"

    def add_new_note(self):
        """Add a new draggable note to the main screen."""
        main_screen = self.sm.get_screen("main")
        layout = main_screen.children[0]
        # Generate a unique ID for the new note
        note_id = str(uuid.uuid4())
        new_note = DraggableNote(note_id=note_id)
        new_note.size_hint = (None, None)
        new_note.size = (250, 300)
        new_note.pos = (40, 120)

        self.notes_positions[note_id] = {"x": 100, "y": 100}
        new_note.bind(
            pos=lambda instance, value, rid=note_id: self.update_note_pos(rid, instance.pos)
        )
        layout.add_widget(new_note)
        self.save_all_positions()

    def update_note_pos(self, note_id, position):
        """Update the position of a note in the dictionary and save."""
        self.notes_positions[note_id] = {"x": position[0], "y": position[1]}
        self.save_all_positions()

    def update_musicplayer_pos(self, pos):
        """Update the position of the music player in the dictionary and save."""
        self.music_player["music_player"] = {"x": pos[0], "y": pos[1]}
        with open("music.json", "w") as f:
                json.dump(self.music_player, f)

    def get_music_files(self):
        """Return a list of audio file paths in the Music folder."""
        music_dir = os.path.join(os.getcwd(), "Music")
        if not os.path.exists(music_dir):
            os.makedirs(music_dir)
        # You can add more extensions if needed
        files = glob.glob(os.path.join(music_dir, "*.mp3")) + \
                glob.glob(os.path.join(music_dir, "*.wav")) + \
                glob.glob(os.path.join(music_dir, "*.ogg"))
        return files

if __name__ == '__main__':
    MainApp().run()