"""Sticky note + music player (Kivy).

A lightweight, insecure (do not store sensitive data) desktop scratchboard:
- Create, drag, recolor, save, and delete sticky notes (each persisted as JSON).
- Drag a simple music player that shuffles royalty‑free tracks from the local Music/ folder.
- Remembers widget positions between runs.

Limitations:
- No auth / encryption.
- Music folder not browsable from the UI (drop files in manually).
- Basic error handling only.

Future ideas (optional):
- Add file picker for music.
- Search / tag notes.
- Export / import notes.
- Dark / light theme toggle.
"""

import json
import os
import uuid
import glob
import random
import logging

from kivy.app import App
from kivy.lang import Builder
from kivy.config import Config
from kivy.clock import Clock
from kivy.core.audio import SoundLoader
from kivy.core.window import Window
from kivy.properties import ObjectProperty, StringProperty, ListProperty
from kivy.uix.behaviors import DragBehavior
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.screenmanager import ScreenManager, Screen
from kivy.uix.progressbar import ProgressBar

# Logging configuration (PEP8: module-level constants / setup near top)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

DEFAULT_NOTE_COLOR = [0.996, 1.0, 0.408, 1]

kv = """
<DraggableRectangle@DragBehavior+FloatLayout>:
    size_hint: None, None
    size: 250, 320
    drag_timeout: 100000000
    drag_distance: 0
    drag_rectangle: self.x, self.y, self.width, self.height

    canvas.before:
        Color:
            rgba: 0.3, 0.3, 0.3, 0.8 
        Rectangle:
            pos: self.x + 3, self.y - 3
            size: self.size
    canvas:
        Color:
            rgba: root.note_color
        Rectangle:
            pos: self.pos
            size: self.size
    BoxLayout:
        orientation: 'vertical'
        size: root.size
        pos: root.pos
        padding: 10
        spacing: 5

        TextInput:
            id: text_input
            hint_text: "Type your note here..."
            size_hint_y: 0.8
            multiline: True
            scroll_y: 1
            on_parent: root.text_input_ref = self
        BoxLayout:
            size_hint_y: 0.2
            spacing: 20
            Button:
                id: note_save
                text: "Save"
                on_release: root.save_note()
            Button:
                id: note_delete
                text: "Delete"
                on_release: root.delete_note()
        BoxLayout:
            orientation: 'horizontal'
            padding: -5
            spacing: 10
            size_hint_y: 0.15
            pos_hint: {"center_x": 0.5}
            Button:
                background_normal: ''
                background_color: 0.996, 1.0, 0.408, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_color(self.background_color)
            Button:
                background_normal: ''
                background_color: 1.0, 0.757, 0.29, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_color(self.background_color)
            Button:
                background_normal: ''
                background_color: 1.0, 0.443, 0.808, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_color(self.background_color)
            Button:
                background_normal: ''
                background_color:  0.729, 0.247, 1.0, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_color(self.background_color)
            Button:
                background_normal: ''
                background_color:  0.463, 0.753, 0.839, 1
                size_hint: None, None
                size: 40, 40
                on_release: root.change_note_color(self.background_color)
<Draggablemusicplayer@DragBehavior+FloatLayout>:
    size_hint: None, None
    size: 320, 360
    drag_timeout: 100000000
    drag_distance: 0
    drag_rectangle: self.x, self.y, self.width, self.height
    current_song: "No song loaded"
    canvas.before:
        Color:
            rgba: 0, 0.1, 0.8, 0.8
        RoundedRectangle:
            pos: self.x + 5, self.y - 5
            size: self.size
    canvas:
        Color:
            rgba: 0.1, 0.2, 1, 1  
        RoundedRectangle:
            pos: self.pos
            size: self.size
    BoxLayout:
        orientation: 'vertical'
        size: root.size
        pos: root.pos
        padding: 10
        spacing: 5
        Label:
            id: song_label
            text: root.current_song
            size_hint_y: 0.1
            size_hint_x: 0.8
            pos_hint: {"center_x": 0.5}
            font_size: self.size[1] * 0.25
        ProgressBar:
            id: progress_bar
            size_hint_y: 0.1
            size_hint_x: 0.9
            pos_hint: {"center_x": 0.5}
            max: 100
            value:0
        GridLayout:
            cols: 3
            size_hint_y: 0.08
            padding: 10
            spacing: 5
            Button:
                text: "Back"
                size_hint_y: 0.08
                on_release: root.play_prev()
            Button:
                id:play pause_button
                text: "Play"
                size_hint_y: 0.08
                on_press: root.toggle_music(self)
            Button:
                text:"Skip"
                size_hint_y: 0.08
                on_release: root.play_next()
<WelcomeScreen>:
    FloatLayout:
        Button:
            text: "Hey there, note-taker!"
            font_size: self.size[1] * 0.6
            size_hint: None, None
            size: 100, 100
            pos_hint: {"center_x": 0.5, "center_y": 0.6}
            background_normal: ''
            background_color: 0, 0, 0, 1
            on_release: app.switch_to_secret()
        Label:
            text: "Big plans? Random thoughts? Let’s jot it all down."
            font_size: self.size[1] * 0.4
            size_hint: None, None
            size: 300, 100
            pos_hint: {"center_x": 0.5, "center_y": 0.5}
        Button:
            background_normal: ''
            background_color: 0.341, 0.514, 0.859, 1
            text: "Enter"
            font_size: self.size[1] * 0.5
            size_hint: 0.13, 0.1
            pos_hint: {"center_x": 0.5, "center_y": 0.35}
            on_release: app.switch_to_main_screen()
        Label:
            text: "Please do NOT save any sensitive information here, as this app is not secure."
            color: 1, 0, 0, 1
            font_size: self.size[1] * 0.5
            size_hint: None, None
            size: 300, 30
            pos_hint: {"center_x": 0.5, "center_y": 0.9}
        Label:
            text: "If you want to quit, just tap the X in the top right corner."
            font_size: self.size[1] * 0.4
            size_hint: None, None
            size: 200, 30
            pos_hint: {"center_x": 0.91, "center_y": 0.96}

<MainScreen>:  
    FloatLayout:
        Button:
            text: 'New Note'
            font_size: self.size[1] * 0.5
            size_hint: 0.13, 0.05
            pos_hint: {"x": 0.02, "y": 0.05}
            on_release: app.add_new_rectangle()
               
<Secret>:
    FloatLayout:
        Image:
            source: 'staring-avatar-guy-meme-template-full-439b18bc.png'
            allow_stretch: True
            keep_ratio: False
    FloatLayout:
        Button:
            text: "Back"
            font_size: self.size[1] * 0.5
            size_hint: 0.05, 0.05
            pos_hint: {"x": 0.02, "y": 0.05}
            on_release: app.switch_to_main_screen()
 """
Builder.load_string(kv)
Config.set('input', 'mouse', 'mouse,disable_multitouch')
Window.maximize()  # Start the app maximised


class WelcomeScreen(Screen):
    """Welcome / landing screen."""
    pass


class MainScreen(Screen):
    """Primary screen holding notes and music player."""
    pass


class Settings(Screen):
    """(Placeholder) settings screen."""
    pass


class Secret(Screen):
    pass

class DraggableRectangle(DragBehavior, FloatLayout):
    """
    A draggable note widget. Allows users to move, edit, and colour notes.
    Each note has a unique ID and saves its position, size, text, and colour.
    """
    dragging_widget = None  # Tracks which note is currently being dragged
    text_input_ref = ObjectProperty(None)
    note_id = StringProperty("note_temp")
    note_color = ListProperty(DEFAULT_NOTE_COLOR)

    def __init__(self, note_id="note_temp", **kwargs):
        super().__init__(**kwargs)
        self.note_id = note_id
        self.size_hint = (None, None)
        self.size = (250, 300)
        Clock.schedule_once(self.load_note, 0.1)
        Clock.schedule_once(lambda dt: self.clamp_to_window(), 0.2)
        Window.bind(size=self._on_window_resize)

    def _on_window_resize(self, *args):
        self.clamp_to_window()

    def clamp_to_window(self):
        """Keep the note fully inside the window."""
        w, h = Window.size
        new_x = min(max(self.x, 0), max(0, w - self.width))
        new_y = min(max(self.y, 0), max(0, h - self.height))
        if (new_x, new_y) != (self.x, self.y):
            self.pos = (new_x, new_y)

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            for child in self.children:
                if child.collide_point(*touch.pos):
                    DraggableRectangle.dragging_widget = self
                    if self.parent:
                        parent = self.parent
                        parent.remove_widget(self)
                        parent.add_widget(self)
                    return super().on_touch_down(touch)
        return super().on_touch_down(touch)

    def on_touch_move(self, touch):
        result = super().on_touch_move(touch)
        if DraggableRectangle.dragging_widget is self:
            self.clamp_to_window()
        return result

    def on_touch_up(self, touch):
        if DraggableRectangle.dragging_widget is self:
            DraggableRectangle.dragging_widget = None
            self.clamp_to_window()
            app = App.get_running_app()
            app.rectangles[self.note_id] = {
                "x": self.x,
                "y": self.y,
                "width": self.width,
                "height": self.height
            }
            app.save_all_positions()
        return super().on_touch_up(touch)

    def save_note(self):
        """
        Save the note text and color to a JSON file.
        """
        note_path = f'Notes/note_{self.note_id}.json'
        data = {}
        # Load existing data if present
        if os.path.exists(note_path):
            with open(note_path, "r", encoding="utf-8") as f:
                try:
                    data = json.load(f)
                except Exception:
                    data = {}
        # Update both note and color
        if self.text_input_ref:
            data["note"] = self.text_input_ref.text
        data["color"] = self.note_color
        with open(note_path, "w", encoding="utf-8") as f:
            json.dump(data, f)

    def load_note(self, dt=None):
        """
        Load the note text and color from a JSON file.
        If the file does not exist, it sets default values.
        """
        note_path = f'Notes/note_{self.note_id}.json'
        try:
            with open(note_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                if self.text_input_ref:
                    self.text_input_ref.text = data.get("note", "")
                self.note_color = data.get("color", DEFAULT_NOTE_COLOR)
        except FileNotFoundError:
            if self.text_input_ref:
                self.text_input_ref.text = ""
            self.note_color = DEFAULT_NOTE_COLOR.copy()

    def delete_note(self):
        """
        Delete the note by removing its JSON file and removes widget from screen.
        Also updates the app's rectangle tracking to remove this note.
        """
        try:
            os.remove(f'Notes/note_{self.note_id}.json')
        except FileNotFoundError:
            pass

        # Inform the main app to remove from position tracking
        app = App.get_running_app()
        if self.note_id in app.rectangles:
            del app.rectangles[self.note_id]
            app.save_all_positions()

        # Remove the widget from the screen
        if self.parent:
            self.parent.remove_widget(self)

    def change_note_color(self, color):
        """Change the color of the note."""
        self.note_color = list(color)  # Ensure it's a list, not a kivy object
        self.save_note_color(color)

    def save_note_color(self, color):
        """Save the note color to a JSON file."""
        note_path = f'Notes/note_{self.note_id}.json'
        # Load existing note data if present
        data = {}
        if os.path.exists(note_path):
            with open(note_path, "r") as f:
                try:
                    data = json.load(f)
                except Exception:
                    data = {}
        data["color"] = list(color)
        with open(note_path, "w") as f:
            json.dump(data, f)

class DraggableMusicPlayer(DragBehavior, FloatLayout):
    """
    A draggable music player widget. Allows users to play, pause, and skip songs
    from a shuffled playlist.
    """
    dragging_widget = None
    sound = None
    current_file_index = 0
    current_song = StringProperty("No song loaded")
    shuffled_playlist = []
    is_playing = False
    paused_position = 0

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.progress_event = None
        self._replacing_track = False
        Clock.schedule_once(lambda dt: self.clamp_to_window(), 0.1)
        Window.bind(size=self._on_window_resize)

    def _on_window_resize(self, *args):
        self.clamp_to_window()

    def clamp_to_window(self):
        """Keep the player fully inside the window."""
        w, h = Window.size
        new_x = min(max(self.x, 0), max(0, w - self.width))
        new_y = min(max(self.y, 0), max(0, h - self.height))
        if (new_x, new_y) != (self.x, self.y):
            self.pos = (new_x, new_y)

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            for child in self.children:
                if child.collide_point(*touch.pos):
                    DraggableMusicPlayer.dragging_widget = self
                    if self.parent:
                        parent = self.parent
                        parent.remove_widget(self)
                        parent.add_widget(self)
                    return super().on_touch_down(touch)
        return super().on_touch_down(touch)

    def on_touch_move(self, touch):
        result = super().on_touch_move(touch)
        if DraggableMusicPlayer.dragging_widget is self:
            self.clamp_to_window()
        return result

    def on_touch_up(self, touch):
        if DraggableMusicPlayer.dragging_widget is self:
            DraggableMusicPlayer.dragging_widget = None
            self.clamp_to_window()
        return super().on_touch_up(touch)

    def update_progress(self, dt):
        """Update progress bar based on current song position."""
        if self.sound and self.is_playing:
            try:
                current_pos = self.sound.get_pos()
                total_length = self.sound.length
                if total_length > 0:
                    self.ids.progress_bar.value = (current_pos / total_length) * 100
                else:
                    self.ids.progress_bar.value = 0
                if total_length > 0 and current_pos >= total_length:
                    self.play_next()
            except Exception as exc:
                logger.debug("Progress update failed: %s", exc)
                self.ids.progress_bar.value = 0

    def play_music(self,song_path):
        """
        Loads and plays the selected song, updating the displayed song name.
        """
        # If an existing sound is playing, stop it without triggering auto-next
        if self.sound:
            self._replacing_track = True
            self.is_playing = False  # prevent auto-next on old sound stop
            try:
                self.sound.unbind(on_stop=self._on_sound_stop)
            except Exception:
                pass
            self.sound.stop()
            self._replacing_track = False
            if self.progress_event:
                self.progress_event.cancel()

        self.sound = SoundLoader.load(song_path)
        if self.sound:
            self.sound.bind(on_stop=self._on_sound_stop)
            self.sound.play()
            self.current_song = os.path.basename(song_path)
            logger.info("Playing song: %s", self.current_song)
            self.is_playing = True
            # smoother progress & quicker end detection
            self.progress_event = Clock.schedule_interval(self.update_progress, 0.1)
        else:
            self.current_song = "Error loading song"
            logger.error("Error loading song: %s", song_path)
            self.is_playing = False
            
            if hasattr(self.ids, 'play_pause_button'):
                self.ids.play_pause_button.text = 'Pause'

    def toggle_music(self, button):
        """Toggle between play and pause states"""
        if not self.shuffled_playlist:
            self.shuffle_playlist()

        if not self.sound and self.shuffled_playlist:
            self.play_current()
            button.text = 'Pause'
        elif self.sound:
            if self.is_playing:
                # mark paused before stopping so on_stop won't advance
                self.is_playing = False
                try:
                    self.sound.unbind(on_stop=self._on_sound_stop)
                except Exception:
                    pass
                self.sound.stop()
                button.text = 'Play'
                if self.progress_event:
                    self.progress_event.cancel()
            else:
                current_song = self.shuffled_playlist[self.current_file_index]
                self.sound = SoundLoader.load(current_song)
                if self.sound:
                    self.sound.bind(on_stop=self._on_sound_stop)
                    if self.paused_position:
                        self.sound.seek(self.paused_position)
                    self.sound.play()
                    self.is_playing = True
                    button.text = 'Pause'
                    self.progress_event = Clock.schedule_interval(self.update_progress, 0.1)

    def shuffle_playlist(self):
        """Shuffle the music files and store as playlist"""
        app = App.get_running_app()
        files = app.get_music_files()
        if files:
            self.shuffled_playlist = files.copy()
            random.shuffle(self.shuffled_playlist)
            self.current_file_index = 0

    def play_next(self):
        """Play next song in shuffled playlist"""
        if self.shuffled_playlist:
            self.current_file_index = (self.current_file_index + 1) % len(self.shuffled_playlist)
            self.play_music(self.shuffled_playlist[self.current_file_index])

    def play_prev(self):
        """Play previous song in shuffled playlist"""
        if self.shuffled_playlist:
            self.current_file_index = (self.current_file_index - 1) % len(self.shuffled_playlist)
            self.play_music(self.shuffled_playlist[self.current_file_index])

    def play_current(self):
        """Play current song in playlist"""
        if self.shuffled_playlist:
            self.play_music(self.shuffled_playlist[self.current_file_index])

    def _on_sound_stop(self, *args):
        """Handle the sound stop event."""
        if not self.is_playing:  # paused or intentionally stopped
            return
        # Natural end -> next track
        Clock.schedule_once(lambda dt: self.play_next(), 0)

class MainApp(App):
    """Main application class for the note-taking and music player app."""
    def build(self):
        """Build the app."""
        self.rectangles = {}
        self.music_player = {}  # for position saving
        self.music_player_widget = None  # optional reference
        self.sm = ScreenManager()
        self.sm.add_widget(WelcomeScreen(name="welcome"))
        self.sm.add_widget(MainScreen(name="main"))
        self.sm.add_widget(Secret(name="secret"))
        self.load_all_positions() 
        return self.sm
        
    def save_all_positions(self):
        """Save all rectangle and music player positions."""
        with open("rectangles.json", "w") as f:
            json.dump(self.rectangles, f)

        with open("music.json", "w") as f:
            json.dump(self.music_player, f)

    def load_all_positions(self):
        """Load all rectangle and music player positions."""
        try:
            with open("rectangles.json", "r") as f:
                self.rectangles = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.rectangles = {}

        try:
            with open("music.json", "r") as f:
                self.music_player = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.music_player = {}

        main_screen = self.sm.get_screen("main")
        layout = FloatLayout()
        main_screen.add_widget(layout)

        # Load saved rectangles
        for rect_id, pos in self.rectangles.items():
            new_rectangle = DraggableRectangle(note_id=rect_id)
            new_rectangle.size_hint = (None, None)
            # Use saved size if available, else default
            width = pos.get("width", 250)
            height = pos.get("height", 320)
            new_rectangle.size = (width, height)
            new_rectangle.pos = (pos["x"], pos["y"])
            new_rectangle.bind(
                pos=lambda instance, value, rid=rect_id: self.update_rectangle_pos(rid, instance.pos)
            )
            layout.add_widget(new_rectangle)

        # Load persistent music player
        pos = self.music_player.get("music_player", {"x": 1440, "y": 20})  # Default position
        music_player = DraggableMusicPlayer()
        music_player.size_hint = (None, None)
        music_player.size = (320, 250)
        music_player.pos = (pos["x"], pos["y"])
        music_player.bind(
            pos=lambda instance, value: self.update_musicplayer_pos(instance.pos)
        )
        layout.add_widget(music_player)
        self.music_player_widget = music_player  # Store a reference if needed

    def switch_to_main_screen(self):
        """Switch to the main screen."""
        self.sm.current = "main"

    def switch_to_secret(self):
        """Switch to the secret screen (not that there is one)."""
        self.sm.current = "secret"

    def add_new_rectangle(self):
        """Add a new draggable rectangle to the main screen."""
        main_screen = self.sm.get_screen("main")
        layout = main_screen.children[0]

        rect_id = str(uuid.uuid4())
        new_rectangle = DraggableRectangle(note_id=rect_id)
        new_rectangle.size_hint = (None, None)
        new_rectangle.size = (250, 300)
        new_rectangle.pos = (100, 100)

        self.rectangles[rect_id] = {"x": 100, "y": 100}
        new_rectangle.bind(
            pos=lambda instance, value, rid=rect_id: self.update_rectangle_pos(rid, instance.pos)
        )
        layout.add_widget(new_rectangle)
        self.save_all_positions()

    def update_rectangle_pos(self, rect_id, position):
        """Update the position of a rectangle in the dictionary and save."""
        self.rectangles[rect_id] = {"x": position[0], "y": position[1]}
        self.save_all_positions()

    def update_musicplayer_pos(self, pos):
        """Update the position of the music player in the dictionary and save."""
        self.music_player["music_player"] = {"x": pos[0], "y": pos[1]}
        with open("music.json", "w") as f:
                json.dump(self.music_player, f)

    def get_music_files(self):
        """Return a list of audio file paths in the Music folder."""
        music_dir = os.path.join(os.getcwd(), "Music")
        if not os.path.exists(music_dir):
            os.makedirs(music_dir)
        # You can add more extensions if needed
        files = glob.glob(os.path.join(music_dir, "*.mp3")) + \
                glob.glob(os.path.join(music_dir, "*.wav")) + \
                glob.glob(os.path.join(music_dir, "*.ogg"))
        return files

if __name__ == '__main__':
    MainApp().run()